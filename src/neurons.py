import numpy as np

class LIFNeurons:
    """ 
        Define Leaky Integrate-and-Fire Neuron Layer 
        This class is complete. You do not need to do anything here.
    """

    def __init__(self, dimension, vdecay, vth):
        """
        Args:
            dimension (int): Number of LIF neurons in the layer
            vdecay (float): voltage decay of LIF neurons
            vth (float): voltage threshold of LIF neurons
        
        """
        self.dimension = dimension
        self.vdecay = vdecay
        self.vth = vth

        # Initialize LIF neuron states
        self.volt = np.zeros(self.dimension)
        self.spike = np.zeros(self.dimension)
    
    def __call__(self, psp_input):
        """
        Args:
            psp_input (ndarray): synaptic inputs 
        Return:
            self.spike: output spikes from the layer
                """
        self.volt = self.vdecay * self.volt * (1. - self.spike) + psp_input
        self.spike = (self.volt > self.vth).astype(float)
        return self.spike

class Connections:
    """ Define connections between spiking neuron layers """

    def __init__(self, weights, pre_dimension, post_dimension):
        """
        Args:
            weights (ndarray): connection weights
            pre_dimension (int): dimension for pre-synaptic neurons
            post_dimension (int): dimension for post-synaptic neurons
        """
        self.weights = weights
        self.pre_dimension = pre_dimension
        self.post_dimension = post_dimension
    
    def __call__(self, spike_input):
        """
        Args:
            spike_input (ndarray): spikes generated by the pre-synaptic neurons
        Return:
            psp: postsynaptic layer activations
        """
        psp = np.matmul(self.weights, spike_input)
        return psp

# class IzhiNeurons():
#     """Implementation of the Izhikevich neuron Model"""
#     def __init__(self, a, b, c, d, Vth, T, dt):
#         """
#         :param a, b, c, d: Izhi neuron parameters
#         :param Vth: Voltage threshold for spiking
#         :param T: Simulation timesteps
#         :param dt: Integration time 
        
#         This function is complete. You do not need to do anything here.
#         """
#         self.a = a
#         self.b = b
#         self.c = c
#         self.d = d
#         self.Vth = Vth
#         self.u = self.b * self.c #initialize u
#         self.T = T
#         self.dt = dt
#         self.t = np.arange(0, self.T, self.dt)
#         self.I = 10 #Input stimulus current
#         self.spike = np.zeros(self.dimension)
        
#     def __call__(self):
#         """
#         Main function to simulate Izhi neuron and plot voltage and current against time. Fill in the update equations for du, dv, v[t] and u[t] and resetting on spiking.
#         """
#         V = np.zeros(len(self.t)) #Initialize a numpy array containing the membrane voltages for all the timesteps
#         V[0] = self.c #Initial membrane voltage is the rest potential, defined by the parameter 'c'
#         u = np.zeros(len(self.t)) #Initialize a numpy array containing u for all the timesteps
#         u[0] = self.u #Initial u

#         for t in range(1, len(self.t)): #the time loop for performing euler's integration
#            dv =  (0.04 * V[t-1] * V[t-1]) + 5 * V[t-1] + 140 - u[t-1] + self.I #compute increment in voltage
#            du =   self.a * (self.b * V[t-1] - u[t-1]) #compute increment in u
#            V[t] =  V[t-1] + dv * self.dt #update the voltage
#            u[t] =  u[t-1] + du * self.dt #update u
           
#            #condition for when membrane potential is greater than the threshold
#            if V[t] >= self.Vth:
#                V[t] =  self.c #reset v
#                u[t] += self.d #reset u
               
               